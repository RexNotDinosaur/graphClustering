import cv2
import os
import time
import math
from Cluster import Cluster
import random
from PIL import Image
from multiprocessing import Process,Queue,cpu_count
from utils import norm,innerproduct,diff,countingThreading


def imageDic(fn:str) ->dict:
    __doc__ = ''' 
        precondition: image file exists in the form of jpeg or png
        :param fn: the name of the file in string
        :return: dictionary of colors in RGB whose key is position tuple
    '''

    img = cv2.imread(fn, cv2.IMREAD_COLOR)
    rows, cols, _ = img.shape
    imgdic = {}
    for r in range(0,rows):
        for c in range(0,cols):
            imgdic[(r,c)]=tuple(img[r,c])
    return imgdic,rows,cols


def weightfunc(x:float)->float:
    __doc__ = '''
    :param x: a distance of to be weighed 
    :return: return the weight function defined as w(x)=(1/x)**2
    
    >>>weightfunc(1)
    1.0
    >>weightfunc(0)
    0
    
    '''
    try:
        return 1/math.pow(x,2)
    except ZeroDivisionError:
        return 0


def singlegrad(q:Queue,imgdic:dict,positionrange,displacement:int):
    __doc__ = '''
    given a range of positions, put into queue the gradients
    precondition:   the positions generated by or from the position range is within the rows and columns of the imgdic
                    displacement is greater than zero
    :param q: the Queue to put data to the main process
    :param imgdic: dictionary of image color tuples in RGB with position as key
    :param positionrange: iterable of all positions to process in this Process
    :param displacement: the radius of positions to contribute to the value of gradient
    :return: None
    '''

    for p in positionrange:
        r,c=p
        DCDR = 0
        Rweight = 0
        for dr in range(-displacement, displacement + 1):
            if dr != 0:
                try:
                    w = weightfunc(dr)
                    DCDR += w * norm(diff(imgdic[(r, c)], imgdic[(r + dr, c)])) / dr
                    Rweight += w
                except KeyError:
                    pass
        DCDC = 0
        Cweight = 0
        for dc in range(-displacement, displacement + 1):
            if dc != 0:
                try:
                    w = weightfunc(dc)
                    DCDC += w * norm(diff(imgdic[(r, c + dc)], imgdic[(r, c)])) / dc
                    Cweight += w
                except KeyError:
                    pass
        try:
            RG=DCDR / Rweight
        except ZeroDivisionError:
            RG=0
        try:
            CG=DCDC / Cweight
        except ZeroDivisionError:
            CG=0
        q.put((p,(RG,CG)))

def generatepositionrange(start:int,end:int,rows:int,cols:int):
    __doc__ = '''
    :param start: the starting index of iterating points
    :param end: end index of iterating points
    :param rows: rows of the image that the index corresponds to
    :param cols: the columns of the image the index corresponds to
    :return: generator of positions within the range of index
    '''
    def prange():
        for i in range(start,end):
            r=(i+1)//cols
            c=i+1-r*cols
            yield (r,c)
    return prange()

def fastGradDic(imgdic,shape,displacement,maxprocess=None):
    __doc__ = '''
    precondition: maxprocess is greater than zero
    :param imgdic: the dictionary of image colors in RGB with position tuple as key
    :param shape: tuple of the rows and columns of the position
    :param displacement: the radius of positions to contribute to the value of gradient
    :param maxprocess:  process number that the algorithm can run, recommended to be None(default) if to achieve the max
                        utility of processors in the computer; to implement the feature of multi-process nature of the 
                        function, it is recommended that maxprocess should at least be 2
    :return: dictionary of gradients
    '''
    if maxprocess==None:
        maxprocess=cpu_count()
        print('maxprocess:',maxprocess)
    rows,cols=shape

    Gdic = {}
    q=Queue()

    total=rows*cols-1
    delta=total//maxprocess+1
    nowindex=0
    lastindex=0
    processlist=[]
    while nowindex<total:
        nowindex=lastindex+delta
        if nowindex>=total:
            nowindex=total
        processlist.append(Process(target=singlegrad,args=(q,imgdic,generatepositionrange(lastindex,nowindex,rows,cols),displacement)))
        lastindex=nowindex

    for p in processlist:
        p.start()


    received=0
    while received<total:
        p,g=q.get()
        received+=1
        Gdic[p]=g

    for p in processlist:
        p.join()
    return Gdic

if __name__=='__main__':
    start=time.time()
    fn='/Users/Rex/Desktop/temppic/38.png'
    imgdic,rows,cols=imageDic(fn)
    print('imgdic',len(imgdic))
    Gdic=fastGradDic(imgdic,(rows,cols),3)
    end=time.time()
    print(end-start)
    print(len(Gdic.keys()))